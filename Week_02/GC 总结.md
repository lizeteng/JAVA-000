# GC 总结
## 什么是 GC
GC（Garbage Collection）是一种自动的管理内存机制，当某个程序占用的部分内存不被该程序访问时，该程序会借助 GC 向系统归还这部分内存空间。

> GC 存在的本质是内存资源的有限性。

## 垃圾收集算法
### 引用计数
为对象附加 1 个计数器，当有其他对象引用这个对象，计数器加 1，反之减 1，然后定期检查尚未被回收的对象的计数器，为 0 则回收。

> 该算法无法回收循环引用的对象。

### 引用跟踪
从根对象出发，查找与之相关的对象，标记其余没有关联的对象，最后回收这些没有关联的对象。

## 垃圾回收算法
### 标记-清除
暂停整个程序运行，进行标记，再进行回收。会产生大量的空闲空间碎片，大容量对象不容易获得连续的内存空间。

### 标记-压缩
和标记-清除类似。不同的是，回收期间会将对象搬运到连续的内存空间，整合空闲空间，避免内存碎片化。

### 复制
将内存分为两部分，程序对象先存储在其中一部分内存（分区 0）。暂停整个程序运行，标记后，回收期间将存活对象搬运到另一部分内存（分区 1），接下来程序产生的对象都存储到分区 1，下一次回收，分区角色对调。

### 分代
由于复制算法对于存活时间长，容量大的对象需要耗费更多的移动时间，和存在对象的存活时间差异，需要将内存分成若干分区，并标记为年轻代和老年代，程序运行所需对象先存在年轻代，年轻代会进行较为激进垃圾回收，每次回收完存活的对象计数器加 1，年轻代对象计数器达到阀值或者占用空间超过阀值，则移动到老年代，老年代垃圾回收操作较少。一般还有永久代，用于程序运行生命周期的对象存储（运行代码、常量等），通常不进行垃圾回收操作。

## 垃圾收集器
> todo：各垃圾收集器总结

### 垃圾收集器对比
![](https://tva1.sinaimg.cn/large/0081Kckwgy1gk5eflfz0nj30u60l4n50.jpg)

### 常用垃圾收集器组合
#### Serial GC
年轻代使用 Serial 收集器，老年代使用 Serial Old 收集器，两者都是单线程的垃圾收集器，不能进行并行处理，所以都会触发 STW，停止所有的应用线程。该 GC CPU 利用率高，暂停时间长，适合小内存、单核 CPU 使用。

#### Parallel GC
年轻代使用 Parallel Scavenge，老年代使用 Parallel Old 收集器，两者垃圾回收都会触发 STW。该 GC 适用于多核服务器，主要目标是增加吞吐量。

#### CMS GC
年轻代使用 ParNew 收集器，老年代使用 CMS 收集器，年轻代会触发 STW，老年代会触发较短 STW，CMS GC 的设计目标是避免老年代垃圾收集时出现长时间的卡顿，如果服务器是多核 CPU，并且主要调优目标是降低 GC 停顿导致的系统延迟，使用 CMS GC 是不错的选择。
